{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/javascript/garbage-collection/",
    "result": {"data":{"cur":{"id":"f8324742-7b5b-565c-8a3e-467fb9b74538","html":"<p>힙과 스택 메모리의 차이를 살펴보고, 자바스크립트 대표 엔진인 V8의 Resident set 구조와 Minor GC, Major GC 의 동작 알고리즘에 대해서 자세하게 살펴 보도록 하겠습니다. 이 글이 가비지 컬렉터가 어떻게 동작하는지 이해하는데 도움이 되길 바랍니다.</p>\n<h2 id=\"v8-메모리-구조-feat-resident-set\" style=\"position:relative;\"><a href=\"#v8-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-feat-resident-set\" aria-label=\"v8 메모리 구조 feat resident set permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V8 메모리 구조 (feat. Resident set)</h2>\n<p>Resident Set은 실행 중인 프로그램의 메모리 관리를 위해 사용되는 용어로, 현재 V8 프로세스가 사용하는 모든 메모리를 나타냅니다. 이것은 JavaScript 코드, 객체, 함수, 변수 등을 저장하는 데 필요한 모든 메모리를 포함합니다. Resident Set은 다음과 같이 여러 세그먼트로 구성됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACcElEQVQoz23IW0xSAQAA0PvRVx/9ttb6a/20WeujpaZMbLblI0dupK1s6s1KHspT8omAvOTp9fKsSMFlKjDloliKOhw+8MHLC1e5gKbVZj9i/02ztlrb+TpAaBuPT89hE15s8l/oR+/6pG8dWdxwL264/aEpX+TYQtizEJ32hbcSwNYmOtEib6QJOSwJt6m7q0HIZorZTAmrUeCkKLuYMq7iZbOc2ipi1JHNBLKOWAnnknS2JnNiMwLgaOwdX5UtVBdrjHe6NeVsCVEKFWuM+WKFuQHiCFoZ02WsyQrWh4f55fqzVbrztcYzD+A+uiUZiwJYPO5hysRVnZrnUg0ogWvFKlCsBiWySr79mYr6pL+2HqLSDXSq4UX1GPmxg/xo9G7J8JumQRyNAJuxONohD9S3hxiiIEMUZIrCXHm0Q77OZAXbeU6WbJShnGiDkRabBRQMgMIBsFtN4nnYMgxFgWgM22tvS4M1aRolTaOkwJpdzqtvRu4XKOsrnP3ddPsAzjqAc/a1Yuj6xd4bl8yEqz1Xzk1Vk7YwHIigWJovwCm0FJeX4jTj9MZ0C39f17mrLvrcW7YLV+xo7u1BFUmVwlKUa71faCMVmQpvfqp/isW3gWgUPTTpMzro8ERGB2UMcMbYd/QaPrIYjt7qM2bohxk+0Cr6b122FWQNl+QYrl3w1ZG3sQSwEksgjjmXfdblOGE/hTjn3YjfjfhdznmXfXZ8ZMZmGrIa31tNQwP6wRHreCCGA55Qktizki9dJsj+kidZKtUGSrWBPOnS8ciXicq1XwqUa4XKVWQDB1bxHW8E/5/kb6czE0784Y3gq/jOT+3klg1v7TstAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"resident-set\"\n        title=\"resident-set\"\n        src=\"/static/6ab08fca9582e106097ade22dbfd9ab0/37523/resident-set.png\"\n        srcset=\"/static/6ab08fca9582e106097ade22dbfd9ab0/e9ff0/resident-set.png 180w,\n/static/6ab08fca9582e106097ade22dbfd9ab0/f21e7/resident-set.png 360w,\n/static/6ab08fca9582e106097ade22dbfd9ab0/37523/resident-set.png 720w,\n/static/6ab08fca9582e106097ade22dbfd9ab0/302a4/resident-set.png 1080w,\n/static/6ab08fca9582e106097ade22dbfd9ab0/07a9c/resident-set.png 1440w,\n/static/6ab08fca9582e106097ade22dbfd9ab0/e8950/resident-set.png 2000w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>출처: memory management in V8</em></p>\n<h3 id=\"stack-vs-heap\" style=\"position:relative;\"><a href=\"#stack-vs-heap\" aria-label=\"stack vs heap permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>stack vs heap</h3>\n<p>메모리 공간은 크게 스택 메모리(Stack memory)와 힙 메모리(Heap memory)로 구분되며, 힙 메모리는 다양한 목적으로 서비스하는 여러 공간으로 더 나누어집니다.</p>\n<script defer class=\"speakerdeck-embed\" data-id=\"e89e2e48a797417eb8692897dcada584\" data-ratio=\"1.77777777777778\" src=\"//speakerdeck.com/assets/embed.js\"></script>\n<p>스택 메모리는 프로그램 실행 중에 사용되는 정적 데이터와 메서드 또는 함수 프레임, 기본값(primitive values), 그리고 객체에 대한 포인터가 저장되는 영역입니다. 코드가 실행되면 엔진은 새로운 데이터를 스택에 넣거나 함수를 호출할 때마다 해당 함수의 프레임을 스택에 추가(<code>push</code>)합니다. 각 프레임은 함수의 지역 변수, 인자, 반환 값 등과 같은 정보를 포함합니다. 함수 호출이 완료되면 프레임은 스택에서 제거(<code>pop</code>)하여 메모리 공간을 해제하므로 자동으로 메모리가 관리됩니다.</p>\n<p>힙 메모리는 코드 실행 중에 언제든지 변경될 수 있는 <strong>동적 데이터를 저장</strong>하며, 가비지 컬렉션(GC)이 이루어지는 영역 입니다. 그러나 힙 메모리 전체가 가비지 컬렉션의 대상이 아니며, New space와 Old space만 가비지 컬렉션에 의해 관리됩니다. New Space는 새로운 객체가 존재하는 공간으로, 대부분의 객체가 짧은 수명을 가지고 있습니다. 이 공간은 작으며, 두 개의 semi-space로 구성됩니다. 이 공간은 **Scavenger(Minor GC)**에 의해 관리됩니다. Old Space는 두 번의 Minor GC 주기 동안 New Space에서 생존한 객체들이 이동하는 공간입니다. 이 공간은 **Major GC(Mark-Sweep-Compact)**에 의해 관리됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAABYlAAAWJQFJUiTwAAACrUlEQVQoz03O+0tTYRzH8Sf/gP6ISOjXkIguVpZFICSlVnS1IkyDbUKkkSBFEURovwVloaKVtTSHm+5+tp2j7jzTnZ3Lc87Zzi7n7JlnF9daw8QfYuGgy5cXn9/e8AVIUiIIcxJGMhZqy0s4gjCKZnz+wCIZ0BUhLTI4KuBYTZTHUiQtMkpUAkpkJrfUpQZMgtMQJwyS25DwGbOL3RgOsqvQGWR73XmDK2+yyCaLtL3WhMmd77bnCTYOMHxWtYGyuY5+CaQ3YHkYpEbrqlZQcdSnJGZ6Jblj5Bd4Xd3xKAoesuA+DR7H695Uwavq+5AGMHxS8jVmloxp4so38m7Wf3ONvJ1dvFUkjqQQ/AyTDV827rn1fv9Wn3/TSHw3ekv9Hn2veWMCpkGGHtBCQyGhND3n6f3wYGjqHbUc48VENtChIWoiqF2dL/xMoE/0S9fKWF5GqshU4uE79vxIMLMdq/RzVi4jJdFmaxknR1I8ZnkxF2jXEDUJ0x1zhSQvXrKcHfT0KaK2yvFJkb8+v/6WxgDDpz88ewpke4lszfpay9bGku1o0X+qROxXUWicinXMYIUP8wghJAqCwPKCJrGdf+OKZ3fe16LaDkRnD6UWDuvekyX/0byrQQ5To2TsorWoyjzHI6F23P9xhh5Ih15ALjdrcXy1uKa/OrxkeDUiaJ5zmkBN0unz1mJc5BgOsfw2hkP/3s7QAyk4HIluiop+YeHya/KdDJMMI+aoi5pATQTVzvlCRQlnpIgub8NSZCO+2mPPvQ1ikIGPy8S+3FJ3jro2at25bNv7w9ZeINpKxEFVhFNQrf+01eVYv2Ev3qy5YS/2ONd3fdwagxjIcEJ3HtFdTbrrWMV7pug9veZtzroOp4hbPLPioLnWmWyTuXDCXDj+xwlzoflzbmFF/g1z7AV1ZtiVwgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"gc\"\n        title=\"gc\"\n        src=\"/static/c8684a659d0d64c043d4765ee567b0e1/37523/gc.png\"\n        srcset=\"/static/c8684a659d0d64c043d4765ee567b0e1/e9ff0/gc.png 180w,\n/static/c8684a659d0d64c043d4765ee567b0e1/f21e7/gc.png 360w,\n/static/c8684a659d0d64c043d4765ee567b0e1/37523/gc.png 720w,\n/static/c8684a659d0d64c043d4765ee567b0e1/302a4/gc.png 1080w,\n/static/c8684a659d0d64c043d4765ee567b0e1/07a9c/gc.png 1440w,\n/static/c8684a659d0d64c043d4765ee567b0e1/e8950/gc.png 2000w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>출처: 카카오엔터테인먼트 기술블로그</em></p>\n<h2 id=\"minor-gc-scavenger\" style=\"position:relative;\"><a href=\"#minor-gc-scavenger\" aria-label=\"minor gc scavenger permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Minor GC (Scavenger)</h2>\n<p>Minor GC(Scavenger)은 V8 엔진에서 new space를 유지하고 정리하는 방법입니다. 객체 생성시 new space에 할당되며, 할당 포인터를 사용하여 새 객체를 위한 공간을 예약할 때마다 할당 포인터를 증가시킵니다. 할당 포인터가 new space의 끝에 도달하면, 더 이상 객체를 할당할 공간이 없는 것이므로 마이너 가비지 컬렉션이 트리거됩니다. 이러한 과정은 <strong>Cheney 알고리즘</strong>을 구현한 Scavenger(청소부)라고 합니다.</p>\n<p>아래 예제를 이용하여 Minor GC(Scavenger)의 과정을 조금 더 자세히 살펴보면,</p>\n<script defer class=\"speakerdeck-embed\" data-id=\"5fff2548e55c4bb0a9c837c7eb598bee\" data-ratio=\"1.77777777777778\" src=\"//speakerdeck.com/assets/embed.js\"></script>\n<p>스택 포인터(GC root)를 시작으로 from-space에 있는 객체 그래프를 재귀적으로 탐색하여 사용 중인 객체 또는 살아있는 객체(used memory)를 찾습니다. 이러한 객체들은 to-space로 이동하고, 이들이 참조하는 다른 객체들도 같이 이동되며 포인터가 업데이트됩니다. 이렇게 from-space의 모든 객체들이 스캔되면, to-space는 자동으로 컴팩트되어 조각화(fragmentation)가 줄어들게 됩니다. 이후 from-space는 더 이상 사용되지 않는 객체들이 모여있는 쓰레기가 되고 비워집니다. 이렇게 to-space와 “from-space”를 교환하여 다음 객체들을 위한 공간을 확보합니다. 이 과정을 반복하여 new space를 유지하고 정리하는 것이 마이너 가비지 컬렉션의 역할입니다.</p>\n<h2 id=\"major-gc-mark-sweep-compact\" style=\"position:relative;\"><a href=\"#major-gc-mark-sweep-compact\" aria-label=\"major gc mark sweep compact permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Major GC (Mark-Sweep-Compact)</strong></h2>\n<p>Major GC는 오래된 세대 공간을 유지하고 정리하는 유형의 가비지 컬렉션입니다. 이것은 마이너 가비지 컬렉션 사이클로부터 오래된 공간이 충분하지 않다고 판단되면(동적으로 계산된 한계에 따라) 트리거됩니다.</p>\n<p><img src=\"/7bccbe1e01240d0a409a8cd80d89e4f9/mark-sweep-compact.gif\" alt=\"mark-sweep-compact\">\n<em>출처: memory management in V8</em></p>\n<p>Major GC는 Old space를 주로 관리하며, 메모리가 부족해지면 주요 GC를 수행하여 메모리 공간을 정리합니다. Scavenger 알고리즘은 작은 데이터 크기에 적합하지만 큰 힙에는 비실용적이므로, 오래된 공간은 메모리 오버헤드가 발생하는 Mark-Sweep-Compact 알고리즘을 사용합니다.</p>\n<ol>\n<li>마킹(Marking): 먼저, GC는 사용 중인 객체와 사용하지 않는 객체를 구별합니다. GC 루트(주로 스택 포인터)에서부터 도달 가능한 객체들을 재귀적으로 마킹하여 “살아있는” 객체로 표시합니다. 이는 힙의 객체들을 그래프로 살펴보는 과정으로 생각할 수 있습니다.</li>\n<li>스위핑(Sweeping): 마킹이 끝나면, GC는 힙을 훑어다니면서 마킹되지 않은 객체들의 메모리 주소를 기록합니다. 이러한 객체들은 더 이상 사용되지 않는 “쓰레기” 객체로 간주되며, 해당 메모리 공간은 다시 사용 가능한 상태가 됩니다.</li>\n<li>컴팩팅(Compacting): 스위핑이 끝난 후, 살아남은 객체들은 필요에 따라 인접한 위치로 이동하여 조각화를 줄입니다. 이렇게 하면 메모리 공간이 더 효율적으로 사용되며, 새로운 객체를 할당하는 성능이 향상됩니다.</li>\n</ol>\n<h2 id=\"상호참조가-있는-경우에도-gc가-제대로-될까\" style=\"position:relative;\"><a href=\"#%EC%83%81%ED%98%B8%EC%B0%B8%EC%A1%B0%EA%B0%80-%EC%9E%88%EB%8A%94-%EA%B2%BD%EC%9A%B0%EC%97%90%EB%8F%84-gc%EA%B0%80-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%90%A0%EA%B9%8C\" aria-label=\"상호참조가 있는 경우에도 gc가 제대로 될까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상호참조가 있는 경우에도 GC가 제대로 될까?</h2>\n<p>상호참조가 있는 경우에도 Cheney 알고리즘과 Mark-Sweep-Compact 알고리즘은 사용중인 객체와 사용하지 않는 객체를 식별하는 과정에서 처리할 수 있습니다. 이러한 알고리즘들은 객체들을 순회하면서 각 객체가 접근 가능한지 여부를 판단하여 사용중인 객체들을 마킹(Marking)하고, 마킹되지 않은 객체들은 가비지로 간주하여 해제하는 방식으로 동작합니다.</p>\n<p>Cheney 알고리즘과 Mark-Sweep-Compact 알고리즘은 모두 어떤 객체를 사용 중인지 여부를 판단하는 과정에서 root를 기준으로 객체의 접근 가능성을 확인합니다. 상호참조가 있더라도 어떤 객체가 마킹되면 해당 객체를 참조하는 다른 객체들도 마킹됩니다. 따라서 상호참조를 가진 객체들 중에서 하나라도 사용중인 객체로 판단되면 모든 상호참조된 객체들이 마킹되어 메모리 누수를 방지하고 가비지 컬렉션을 정확하게 수행할 수 있습니다.</p>\n<p>Mark-Sweep-Compact 알고리즘의 경우는 마킹 단계에서 객체의 접근 가능성을 확인하고, 마킹되지 않은 객체들을 스위핑(Sweeping)하여 가비지로 간주하고 메모리를 해제합니다. 이 때 상호참조가 있는 경우에도 모든 상호참조된 객체들이 마킹된 상태라면 모든 객체들이 적절하게 스위핑되고 메모리가 해제됩니다.</p>\n<p>결론적으로, Cheney 알고리즘과 Mark-Sweep-Compact 알고리즘은 상호참조가 있음에도 사용중인지 아닌지를 판단하여 가비지 컬렉션을 정확하게 수행할 수 있습니다. 이러한 알고리즘들은 상호참조로 인한 메모리 누수를 방지하고 메모리를 효율적으로 관리하는데에 효과적입니다. 다만, 알고리즘의 성능과 효율성은 객체들의 관계와 데이터 크기에 따라 달라질 수 있으므로, 특정 상황에 맞춰 적절한 알고리즘을 선택하는 것이 중요합니다.</p>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://ko.javascript.info/garbage-collection\">https://ko.javascript.info/garbage-collection</a></li>\n<li><a href=\"https://ui.toast.com/weekly-pick/ko_20200228\">https://ui.toast.com/weekly-pick/ko_20200228</a></li>\n<li><a href=\"https://ui.toast.com/weekly-pick/ko_20200228\">https://ui.toast.com/weekly-pick/ko_20200228</a></li>\n<li><a href=\"https://yceffort.kr/2020/12/javascript-garbage-collection\">https://yceffort.kr/2020/12/javascript-garbage-collection</a></li>\n<li><a href=\"https://betterprogramming.pub/deep-dive-into-garbage-collection-in-javascript-6881610239a\">https://betterprogramming.pub/deep-dive-into-garbage-collection-in-javascript-6881610239a</a></li>\n<li><a href=\"https://betterprogramming.pub/deep-dive-into-garbage-collection-in-javascript-6881610239a\">A Deep Dive Into Garbage Collection in JavaScript</a></li>\n<li><a href=\"https://www.memorymanagement.org/\">https://www.memorymanagement.org/</a></li>\n<li><a href=\"https://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection\">A tour of V8: Garbage Collection</a></li>\n<li><a href=\"https://dev.to/jennieji/memory-management-in-v8-garbage-collection-and-improvements-18e6\">Memory Management in V8, garbage collection and improvements</a></li>\n<li><a href=\"https://deepu.tech/memory-management-in-v8/\">🚀 Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)</a></li>\n</ul>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","excerpt":"힙과 스택 메모리의 차이를 살펴보고, 자바스크립트 대표 엔진인 V8의 Resident set 구조와 Minor GC, Major GC 의 동작 알고리즘에 대해서 자세하게 살펴 보도록 하겠습니다. 이 글이 가비지 컬렉터가 어떻게 동작하는지 이해하는데 도움이 되길 바랍니다. V8 메모리 구조 (feat. Resident set) Resident Set은 실행 중인 프로그램의 메모리 관리를 위해 사용되는 용어로, 현재 V8 프로세스가 사용하는 모든 메모리를 나타냅니다. 이것은 JavaScript 코드, 객체, 함수, 변수 등을 저장하는 데 필요한 모든 메모리를 포함합니다. Resident Set은 다음과 같이 여러 세그먼트로 구성됩니다. \n출처: memory management in V8 stack vs heap 메모리 공간은 크게 스택 메모리(Stack memory)와 힙 메모리(Heap memory)로 구분되며, 힙 메모리는 다양한 목적으로 서비스하는 여러 공간으로 더 나누어집니다.…","frontmatter":{"date":"July 14, 2023","title":"자바스크립트 가비지 컬렉션 알고리즘","categories":"javascript","author":"soobing"},"fields":{"slug":"/javascript/garbage-collection/"}},"next":{"id":"2bd30764-0e2e-533c-aef7-a57ee0251031","html":"<blockquote>\n<p>원문: <a href=\"https://www.tecforfun.com/frameworks/how-to-manage-server-state-with-react-query/\">https://www.tecforfun.com/frameworks/how-to-manage-server-state-with-react-query/</a></p>\n</blockquote>\n<p>React Query는 React 애플리케이션에서 데이터 페칭과 캐싱 프로세스를 간소화하는 라이브러리입니다. 이 라이브러리는 API와 기타 데이터 소스로부터 데이터를 페칭하고 업데이트하는 데 필요한 도구와 유틸리티를 제공하며 데이터 페칭의 상태와 캐싱을 자동으로 관리합니다. 이 라이브러리는 React 컴포넌트에서 데이터를 더 쉽게 다룰 수 있도록 다양한 훅과 유틸리티를 제공합니다.</p>\n<p>이 포스트에서는 React Query의 주요 기능에 대해 이야기하겠습니다. 여기서 제 목적은 가능한 한 빨리 React Query를 사용하여 작업을 시작할 수 있는 출발점을 제공하는 것입니다.</p>\n<p>React 앱 개발에 경험이 있다면, 클라이언트 상태 관리를 위해 Redux와 같은 라이브러리를 사용한 적이 있을 수 있습니다. 반면에, React Query는 서버 상태를 관리하기 위한 라이브러리입니다. 그러므로 React Query에 대해 이야기하기 전에 클라이언트 상태와 서버 상태의 차이에 대해 알아보도록 하겠습니다.</p>\n<h2 id=\"클라이언트-상태-vs-서버-상태\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%83%81%ED%83%9C-vs-%EC%84%9C%EB%B2%84-%EC%83%81%ED%83%9C\" aria-label=\"클라이언트 상태 vs 서버 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클라이언트 상태 vs 서버 상태</h2>\n<p>클라이언트 상태와 서버 상태의 차이점을 살펴보겠습니다. 이는 React Query가 어떤 역할을 하는지와 서버 상태 관리를 위해 다른 라이브러리가 왜 필요한지를 이해하는 데 도움이 됩니다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>클라이언트 상태</th>\n<th>서버 상태</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>위치</td>\n<td>클라이언트(브라우저 또는 기기)에 저장된 데이터</td>\n<td>서버나 외부 데이터 소스에 저장된 데이터</td>\n</tr>\n<tr>\n<td>접근성</td>\n<td>저장한 클라이언트만 접근 가능</td>\n<td>접근 권한이 있는 모든 클라이언트 접근 가능</td>\n</tr>\n<tr>\n<td>데이터 관리</td>\n<td>클라이언트에서 관리(예: Redux와 같은 상태 관리 라이브러리 사용)</td>\n<td>서버에서 관리(예: 데이터베이스 사용)</td>\n</tr>\n<tr>\n<td>지속성</td>\n<td>세션 간에 지속성이 유지되거나 유지되지 않을 수 있음</td>\n<td>일반적으로 세션 간에 지속성 유지</td>\n</tr>\n<tr>\n<td>네트워크 요청</td>\n<td>데이터를 가져오거나 업데이트하려면 네트워크 요청이 필요할 수 있음</td>\n<td>데이터 접근 또는 업데이트를 위해 네트워크 요청이 필요할 수 있음</td>\n</tr>\n<tr>\n<td>보안</td>\n<td>클라이언트가 액세스할 수 있고 변조 또는 가로채기의 대상이 될 수 있으므로 보안 수준이 낮을 수 있음</td>\n<td>인증 및 암호화로 보호할 수 있으므로 더 안전할 수 있음</td>\n</tr>\n<tr>\n<td>성능</td>\n<td>네트워크 요청이 필요하지 않기 때문에 서버 상태에 비해 접근하고 업데이트하는 속도가 빠를 수 있음</td>\n<td>네트워크 요청이 필요할 수 있으므로 클라이언트 상태에 비해 접근하고 업데이트하는 속도가 느릴 수 있음</td>\n</tr>\n<tr>\n<td>확장성</td>\n<td>클라이언트 기기의 용량에 제한을 받을 수 있기 때문에 서버 상태보다 확장성이 떨어질 수 있음</td>\n<td>전용 서버나 고용량의 데이터 소스로 관리되기 때문에 클라이언트 상태보다 확장성이 더 높을 수 있음</td>\n</tr>\n<tr>\n<td>예시</td>\n<td>컴포넌트 상태, Redux 상태, 브라우저 쿠키</td>\n<td>데이터베이스 레코드, API 응답, 서버 세션 데이터</td>\n</tr>\n</tbody>\n</table>\n<p>표: 클라이언트 상태 vs 서버 상태</p>\n<p>기존에는 React 개발자들은 클라이언트 상태 관리를 위해 Redux나 React Context API를 사용해왔습니다. API 데이터와 상호작용할 때에는 주로 <a href=\"https://www.tecforfun.com/frameworks/how-to-create-a-dynamic-table-in-react-with-api-data/\"><code>useState</code> 훅과 <code>useEffect</code> 훅의 조합</a>을 통해 fetch API 데이터를 가져와 클라이언트 상태에 반영합니다.</p>\n<p>React Query는 API 데이터를 캐싱하고 관리하기 위한 훅과 유틸리티를 제공함으로써, 원격 데이터 소스로부터 데이터 페칭을 위해 사용하는 <code>useState</code>와 <code>useEffect</code> 훅을 대체할 수 있는 라이브러리입니다. 이 라이브러리는 API 데이터를 가져오는 과정을 간소화하고, 캐시를 처리하며, API 요청의 로딩 및 오류 상태를 관리합니다.</p>\n<h2 id=\"react-query에서의-네-가지-기본-개념\" style=\"position:relative;\"><a href=\"#react-query%EC%97%90%EC%84%9C%EC%9D%98-%EB%84%A4-%EA%B0%80%EC%A7%80-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90\" aria-label=\"react query에서의 네 가지 기본 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Query에서의 네 가지 기본 개념</h2>\n<p>React Query를 사용하기 위해 반드시 이해해야 할 네 가지 기본 개념이 있습니다.</p>\n<ol>\n<li>쿼리(Queries):\n<ol>\n<li>API 엔드포인트나 데이터베이스와 같은 원격 데이터 소스로부터 데이터를 요청</li>\n<li><code>useQuery</code> 훅을 사용하여 관리됨</li>\n</ol>\n</li>\n<li>뮤테이션(Mutations)\n<ol>\n<li>서버에 새로운 데이터를 추가하거나 기존 데이터를 수정하는 요청</li>\n<li><code>useMutation</code> 훅을 사용하여 관리됨</li>\n</ol>\n</li>\n<li>쿼리 캐싱(Query Caching): 쿼리 캐싱은 React Query의 내장 기능으로, 쿼리 결과를 메모리에 저장</li>\n<li>쿼리 무효화(Query Invalidation): 쿼리를 무효하거나 오래된 상태로 표시하는 과정</li>\n</ol>\n<h2 id=\"usequery-훅으로-데이터-페칭\" style=\"position:relative;\"><a href=\"#usequery-%ED%9B%85%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%8E%98%EC%B9%AD\" aria-label=\"usequery 훅으로 데이터 페칭 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useQuery 훅으로 데이터 페칭</h2>\n<p>공식 문서에서 “쿼리는 고유 키에 연결된 데이터의 비동기 소스에 대한 선언적 종속성(declarative dependency)입니다.”라고 나와 있습니다.</p>\n<p>정말 복잡한 설명이네요 !!!!</p>\n<p>여기에서 <strong>선언적 종속성</strong>은 코드(useQuery훅 사용)에서 선언한 쿼리를 나타냅니다. 이 쿼리는 API 데이터 포인트 또는 데이터베이스에서 <strong>비동기적으로</strong> 데이터를 가져오도록 서버에 요청하는 것입니다.</p>\n<p>이제 <code>useQuery</code> 훅으로 어떻게 이 작업을 수행하는 방법을 살펴보겠습니다.</p>\n<p>useQuery 훅은 두 가지 필수 옵션(프로퍼티)을 사용합니다.</p>\n<ol>\n<li><strong>고유한 키</strong></li>\n<li><strong>promise를 반환하는 함수</strong></li>\n</ol>\n<p>코드 구문:</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"jsx\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> </span><span class=\"mtk12\">query</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">useQuery</span><span class=\"mtk1\">( { </span><span class=\"mtk12\">queryKey:</span><span class=\"mtk1\"> [ ‘</span><span class=\"mtk12\">key</span><span class=\"mtk1\">’ ],   </span><span class=\"mtk12\">queryFn:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">callback</span><span class=\"mtk1\"> })</span></span></span></code></pre>\n<p><code>querykey</code> 는 고유한 키 입니다. React Query의 최신 안정 버전에서는 이 키를 지정하기 위해 배열 표기법을 사용해야 합니다.</p>\n<p><code>queryFn</code> 은 useQuery 훅이 호출될 때 React Query에 의해 실행되는 콜백 함수입니다. 이 함수는 <code>useQuery</code> 훅의 실행 중에 특정 시점에서 명세한 작업(데이터 페칭)을 수행합니다.</p>\n<p><a href=\"https://www.tecforfun.com/ezoic/video/embed.go?contentId=56315d685adc63fc646ee2880771f3badc50210195c93583c60972921a420f7a\">https://www.tecforfun.com/ezoic/video/embed.go?contentId=56315d685adc63fc646ee2880771f3badc50210195c93583c60972921a420f7a</a></p>\n<p><a href=\"https://humix.com/redirect?url=https%3A%2F%2Fwebninjadeveloper.com%2Fhumix%2Fvideo%2F56315d685adc63fc646ee2880771f3badc50210195c93583c60972921a420f7a\">자바스크립트 페치 API 예제 - A Real World App</a></p>\n<p>이 두 가지 옵션 외에 선택적 프로퍼티를 가질 수도 있습니다. 다음 섹션에서 중요한 몇 가지를 다룰 예정 입니다.</p>\n<p>예시:</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"jsx\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> </span><span class=\"mtk11\">getProducts</span><span class=\"mtk1\"> = () </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk11\">fetch</span><span class=\"mtk1\">( </span><span class=\"mtk8\">&#39;https://jsonplaceholder.typicode.com/users&#39;</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">                          .</span><span class=\"mtk11\">then</span><span class=\"mtk1\">( </span><span class=\"mtk12\">res</span><span class=\"mtk1\">  </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk12\">res</span><span class=\"mtk1\">.</span><span class=\"mtk11\">json</span><span class=\"mtk1\">() )</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> </span><span class=\"mtk12\">query</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">useQuery</span><span class=\"mtk1\">( { </span><span class=\"mtk12\">queryKey:</span><span class=\"mtk1\"> [‘</span><span class=\"mtk12\">users</span><span class=\"mtk1\">’],   </span><span class=\"mtk12\">queryFn:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">getTodos</span><span class=\"mtk1\"> })</span></span></span></code></pre>\n<h2 id=\"무엇을-반환하는가\" style=\"position:relative;\"><a href=\"#%EB%AC%B4%EC%97%87%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"무엇을 반환하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>무엇을 반환하는가</h2>\n<p><code>useQuery</code> 훅은 객체를 반환합니다. 이 객체는 쿼리의 상태에 대한 정보가 포함되어 있습니다. 중요한 프로퍼티 및 메서드 중 일부는 아래와 같습니다.</p>\n<p><strong>프로퍼티</strong></p>\n<ol>\n<li><code>data</code>: 성공적으로 페칭된 경우 쿼리로부터 반환된 데이터</li>\n<li><code>error</code>: (에러가 발생했다면) 쿼리 도중 발생한 모든 에러</li>\n<li><code>isLoading</code>: 쿼리가 현재 로딩 중인지 여부를 나타내는 불리언 값</li>\n<li><code>isError</code>: 쿼리 결과가 오류인지 여부를 나타내는 불리언 값</li>\n</ol>\n<p><strong>메서드</strong></p>\n<ul>\n<li><code>refetch</code>: 쿼리 데이터를 수동으로 리페치 하도록 트리거하는 함수</li>\n<li><code>remove</code>: 캐시에서 특정 쿼리를 제거할 수 있는 함수</li>\n</ul>\n<p>따라서, 이러한 프로퍼티들의 값에 접근하기 위해 자바스크립트 구조 분해 할당을 사용할 수 있습니다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"jsx\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> { </span><span class=\"mtk12\">isLoading</span><span class=\"mtk1\">, </span><span class=\"mtk12\">isError</span><span class=\"mtk1\">, </span><span class=\"mtk12\">data</span><span class=\"mtk1\">, </span><span class=\"mtk12\">error</span><span class=\"mtk1\"> } = </span><span class=\"mtk11\">useQuery</span><span class=\"mtk1\">( { </span><span class=\"mtk12\">queryKey:</span><span class=\"mtk1\"> [‘</span><span class=\"mtk12\">todos</span><span class=\"mtk1\">’], </span><span class=\"mtk12\">queryFn:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">getTodos</span><span class=\"mtk1\"> });</span></span></span></code></pre>\n<p><a href=\"https://tanstack.com/query/v4/docs/react/reference/useQuery\">공식 문서에서 <code>useQuery</code>의 모든 레퍼런스</a>를 확인할 수 있습니다.</p>\n<h2 id=\"usequery와-데이터-리페칭-api\" style=\"position:relative;\"><a href=\"#usequery%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%A6%AC%ED%8E%98%EC%B9%AD-api\" aria-label=\"usequery와 데이터 리페칭 api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useQuery와 데이터 리페칭 API</h2>\n<p>기본적으로, <code>useQuery</code>는 컴포넌트가 처음으로 마운트될 때 API에서 데이터를 자동으로 페칭합니다. 그러나 데이터의 이후 업데이트는 자동으로 가져오지 않습니다. 다시 말해, API 엔드포인트나 서버에서 업데이트가 발생한 후에도 <code>useQuery</code>는 데이터를 다시 가져오지 않습니다.</p>\n<p>기본적으로, <code>useQuery</code>의 옵션인 <code>refetchOnMount</code>, <code>refetchOnReconnect</code>, <code>refetchOnWindowFocus</code>와 같은 값들은 true로 설정됩니다.</p>\n<p>다음 표를 살펴보세요.</p>\n<table>\n<thead>\n<tr>\n<th>useQuery 옵션</th>\n<th>역할</th>\n<th>기본값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>refetchOnWindowFocus</td>\n<td>데이터가 오래된(stale) 경우 브라우저 창이 포커스 되면 리페치</td>\n<td>true</td>\n</tr>\n<tr>\n<td>refetchOnMount</td>\n<td>데이터가 오래된 경우 마운트 시 리페치</td>\n<td>true</td>\n</tr>\n<tr>\n<td>refetchOnReconnect</td>\n<td>데이터가 오래된 경우 재연결 시 리페치</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<p>브라우저를 백그라운드에서 유휴(idle) 상태로 유지하는 상황을 가정해 보겠습니다. 누군가는 API 데이터/서버를 업데이트하기 위해 요청을 보내고 데이터가 업데이트됩니다. 그러나 브라우저는 백그라운드에 있기 때문에 UI가 업데이트되지 않습니다. useQuery에는 API 엔드포인트/서버에서 업데이트된 데이터를 다시 가져올 트리거가 없습니다. 이러한 상황에서는 <code>refetchInterval</code> 옵션을 사용할 수 있습니다. 이 옵션을 사용하면 지정된 밀리초 단위의 주기로 useQuery를 실행하여 데이터를 다시 가져올 수 있습니다. 이렇게 하면 브라우저 창이 유휴(idle) 상태일 때에도 데이터를 다시 가져올 수 있습니다.</p>\n<h2 id=\"usemutation-훅을-사용하여-데이터를-생성-업데이트-및-삭제\" style=\"position:relative;\"><a href=\"#usemutation-%ED%9B%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%83%9D%EC%84%B1-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%B0%8F-%EC%82%AD%EC%A0%9C\" aria-label=\"usemutation 훅을 사용하여 데이터를 생성 업데이트 및 삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMutation 훅을 사용하여 데이터를 생성, 업데이트 및 삭제</h2>\n<p>이제 <code>useMutation</code> 훅을 살펴보겠습니다. 이 훅을 사용하여 API 엔드포인트나 서버에서 데이터를 생성, 업데이트 또는 삭제할 수 있습니다.</p>\n<p><code>useMutation</code> 훅은 적어도 하나의 옵션을 필요로 하며, 다른 옵션은 모두 선택적입니다.</p>\n<p>코드 구문:</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"jsx\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> </span><span class=\"mtk12\">mutation</span><span class=\"mtk1\"> =  </span><span class=\"mtk11\">useMutation</span><span class=\"mtk1\">({  </span><span class=\"mtk12\">mutationFn:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">mutationFunction</span><span class=\"mtk1\"> })</span></span></span></code></pre>\n<p>예시:</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"jsx\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> </span><span class=\"mtk12\">AddUser</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">useMutation</span><span class=\"mtk1\">({</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk11\">mutationFn</span><span class=\"mtk12\">:</span><span class=\"mtk1\"> ( </span><span class=\"mtk12\">user</span><span class=\"mtk1\"> ) </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">fetch</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&#39;https://jsonplaceholder.typicode.com/users&#39;</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          </span><span class=\"mtk12\">method:</span><span class=\"mtk8\">&#39;post&#39;</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          </span><span class=\"mtk12\">headers:</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">             </span><span class=\"mtk8\">&quot;Content-Type&quot;</span><span class=\"mtk12\">:</span><span class=\"mtk1\"> </span><span class=\"mtk8\">&quot;application/json&quot;</span><span class=\"mtk1\">,          </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          },</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          </span><span class=\"mtk12\">body:</span><span class=\"mtk10\">JSON</span><span class=\"mtk1\">.</span><span class=\"mtk11\">stringify</span><span class=\"mtk1\">( </span><span class=\"mtk12\">user</span><span class=\"mtk1\"> )</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        }).</span><span class=\"mtk11\">then</span><span class=\"mtk1\">( </span><span class=\"mtk12\">res</span><span class=\"mtk1\"> </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\">  </span><span class=\"mtk12\">res</span><span class=\"mtk1\">.</span><span class=\"mtk11\">json</span><span class=\"mtk1\">() )</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      })</span></span></span></code></pre>\n<h2 id=\"무엇을-반환하는가-1\" style=\"position:relative;\"><a href=\"#%EB%AC%B4%EC%97%87%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%98%EB%8A%94%EA%B0%80-1\" aria-label=\"무엇을 반환하는가 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>무엇을 반환하는가</h2>\n<p><code>useMutation</code> 훅은 객체를 반환합니다. 이 객체에는 뮤테이션과 상호 작용하고 결과를 처리하는 데 사용할 수 있는 여러 프로퍼티와 메서드가 포함되어 있습니다. 그 중 일부는 다음과 같습니다.</p>\n<p><strong>프로퍼티</strong></p>\n<ul>\n<li><code>isLoading</code>: 현재 뮤테이션이 진행 중인지 여부를 나타내는 불리언 값</li>\n<li><code>isSuccess</code>: 뮤테이션이 성공적으로 완료되었는지 여부를 나타내는 불리언 값</li>\n<li><code>isError</code>: 뮤테이션 중에 오류가 발생했는지 여부를 나타내는 불리언 값</li>\n<li><code>data</code>: (데이터가 있다면) 뮤테이션에 의해 반환된 데이터</li>\n</ul>\n<p><strong>메서드</strong></p>\n<ul>\n<li><code>mutate</code>: 이 뮤테이션을 실행하기 위해 호출할 수 있는 함수. 첫 번째 인자로 필요한 변수를 가진 객체를 전달 가능</li>\n<li><code>reset</code>: 뮤테이션을 초기 상태로 리셋하는 함수</li>\n<li><code>onSuccess</code>: 뮤테이션이 성공적으로 완료되었을 때 호출될 콜백을 정의할 수 있는 함수</li>\n<li><code>onError</code>: 뮤테이션 중 오류가 발생했을 때 호출될 콜백을 정의할 수 있는 함수</li>\n</ul>\n<p><code>[useMutation</code> 훅에 대한 모든 레퍼런스는 공식문서](<a href=\"https://tanstack.com/query/v4/docs/react/reference/useMutation)%EC%97%90%EC%84%9C\">https://tanstack.com/query/v4/docs/react/reference/useMutation)에서</a> 확인할 수 있습니다.</p>\n<h2 id=\"react-query에서의-쿼리-캐싱\" style=\"position:relative;\"><a href=\"#react-query%EC%97%90%EC%84%9C%EC%9D%98-%EC%BF%BC%EB%A6%AC-%EC%BA%90%EC%8B%B1\" aria-label=\"react query에서의 쿼리 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Query에서의 쿼리 캐싱</h2>\n<p>useQuery 훅을 사용하여 원격 서버에서 일부 사용자 데이터를 가져오는 경우가 있다고 가정해 봅시다. 데이터를 받는 동안 시간이 걸릴 수 있습니다. React Query는 이 사용자 데이터를 캐시에 저장하여 이후 동일한 요청 시 더 빠르게 찾을 수 있도록 합니다. 이를 통해 데이터 로드하는 데 걸리는 시간을 줄일 수 있습니다.</p>\n<p>앞서 언급한 대로, useQuery 훅은 고유한 키를 사용합니다. 서버에서 반환된 데이터는 이 키 아래에 캐시됩니다. 예를 들어, <code>[‘users’]</code>를 키로 사용한다면, 이 키는 캐시에서 동일한 API 엔드포인트에 대한 후속 요청 데이터를 추출하는 데 사용될 것입니다.</p>\n<p>기본적으로, useQuery는 이 캐시 데이터를 오래된(stale) 상태로 표시합니다. React Query 캐싱과 관련된 두 가지 옵션을 알아야 합니다. 바로 <code>staleTime</code>과 <code>cacheTime</code>입니다.</p>\n<p><code>staleTime</code>: 쿼리 결과가 오래된 것으로 간주되는 데 걸리는 시간을 결정합니다. 시간은 밀리초로 지정됩니다.</p>\n<p>예: <code>staleTime: 5000</code> // 데이터는 최대 5초 동안 stale 상태로 유지됨</p>\n<p>이는 데이터가 5초가 지난 후에 stale 상태가 됨을 의미합니다.</p>\n<p>반면에, <code>cacheTime</code> 옵션은 쿼리 결과가 캐시에 유지되는 시간을 지정합니다.</p>\n<p>예: <code>cacheTime: 60000</code> // 데이터가 1분 동안 캐시에 유지됨</p>\n<p>이는 쿼리 결과가 1분 동안 캐시에 유지되며 그 이후에는 데이터가 가비지 컬렉션됨을 의미합니다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"jsx\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> </span><span class=\"mtk12\">query</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">useQuery</span><span class=\"mtk1\">({</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">queryKey:</span><span class=\"mtk1\"> [‘</span><span class=\"mtk12\">users</span><span class=\"mtk1\">’],</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">queryFn:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">getUsers</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">staleTime:</span><span class=\"mtk1\"> </span><span class=\"mtk7\">5000</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">cacheTime:</span><span class=\"mtk1\"> </span><span class=\"mtk7\">60000</span><span class=\"mtk1\"> </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    })</span></span></span></code></pre>\n<h2 id=\"react-query에서의-쿼리-무효화invalidation\" style=\"position:relative;\"><a href=\"#react-query%EC%97%90%EC%84%9C%EC%9D%98-%EC%BF%BC%EB%A6%AC-%EB%AC%B4%ED%9A%A8%ED%99%94invalidation\" aria-label=\"react query에서의 쿼리 무효화invalidation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Query에서의 쿼리 무효화(Invalidation)</h2>\n<p>이전에 설명한 대로, 캐시에 저장된 데이터는 staleTime 옵션에 따라 오래된 데이터로 처리될 수 있습니다. 그러나 특정 상황에서는 <code>staleTime</code>을 무시하고 데이터를 무효화시키거나 오래되었다고 표시해야 하는 상황이 발생할 수 있습니다. 예를 들어, API에 POST 요청을 보낼 때는 API 엔드포인트의 데이터가 최신 데이터이므로 수동으로 캐시에 있는 데이터를 유효하지 않은 것으로 표시해야 합니다. 결과적으로, POST 요청 후에는 즉시 캐시의 데이터가 오래되었다고 간주됩니다.</p>\n<p>이를 해결하기 위해, React Query의 <code>QueryClient</code> 객체는 <code>invalidateQueries</code> 메서드를 제공합니다. 이 메서드는 모든 쿼리 또는 특정 쿼리를 오래된(stale) 상태로 표시할 수 있습니다. 또한 고유한 키를 사용하여 특정 쿼리를 오래된 상태로 표시할 수도 있습니다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"jsx\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">import</span><span class=\"mtk1\"> { </span><span class=\"mtk12\">useQueryClient</span><span class=\"mtk1\"> } </span><span class=\"mtk15\">from</span><span class=\"mtk1\"> </span><span class=\"mtk8\">&#39;@tanstack/react-query&#39;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// useQueryClient 훅을 사용하여 queryClient 객체 생성</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">const</span><span class=\"mtk1\"> </span><span class=\"mtk12\">queryClient</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">useQueryClient</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 캐시의 모든 쿼리 무효화</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">queryClient</span><span class=\"mtk1\">.</span><span class=\"mtk11\">invalidateQueries</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// &#39;users&#39;로 시작하는 키가 있는 모든 쿼리 무효화</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">queryClient</span><span class=\"mtk1\">.</span><span class=\"mtk11\">invalidateQueries</span><span class=\"mtk1\">({ </span><span class=\"mtk12\">queryKey:</span><span class=\"mtk1\"> [</span><span class=\"mtk8\">&#39;users&#39;</span><span class=\"mtk1\">] })</span></span></span></code></pre>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>이 글에서는 React Query가 무엇인지와 그 필요성에 대해 다뤘습니다. React Query는 서버 상태를 관리하기 위한 강력한 라이브러리입니다. 이는 <code>useQuery</code>와 같은 React 훅을 활용하여 API 엔드포인트나 서버에서 데이터를 가져오고 <code>useMutation</code>을 사용하여 원격 데이터를 조작합니다. React Query는 메모리 내 캐시를 관리하는 스마트 캐싱 메커니즘을 갖추고 있습니다. 이를 통해 캐시가 원격 데이터 소스와 동기화되도록 보장합니다. React Query를 사용하면, 코드를 간소화하고 React 애플리케이션의 성능을 최적화할 수 있습니다.</p>\n<h2 id=\"resources\" style=\"position:relative;\"><a href=\"#resources\" aria-label=\"resources permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Resources</h2>\n<p><a href=\"https://github.com/dineshigdd/react-query-js\">전체 코드 다운로드</a></p>\n<p>참고: 데모 프로젝트에서는 <a href=\"https://mockapi.io/\">mockapi.io</a>로 생성한 모의 API를 활용합니다. 그러나 mockapi.io를 사용하여 직접 자신만의 API 엔드포인트를 생성하는 것을 강력히 추천합니다. 이는 배우는 동안 실험을 하는 것이 더 쉬울 수 있기 때문입니다.</p>\n<p><a href=\"https://www.tecforfun.com/misc/how-to-set-up-mock-api-at-mockapi-io/\">mockapi.io에서 모의 API를 만드는 방법</a> 알아보기</p>\n<p><a href=\"https://tanstack.com/query/v4/docs/react/installation\">React Query 설치</a></p>\n<p><a href=\"https://tanstack.com/query/v4/docs/react/guides/queries\">React Query에서 쿼리들</a></p>\n<p><a href=\"https://tanstack.com/query/v4/docs/react/guides/mutations\">React Query 에서 뮤테이션들</a></p>\n<p><a href=\"https://tanstack.com/query/v4/docs/react/guides/query-invalidation\">React Query에서 쿼리 무효화</a></p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .default-dark .mtk4 { color: #569CD6; }\n  .default-dark .mtk1 { color: #D4D4D4; }\n  .default-dark .mtk12 { color: #9CDCFE; }\n  .default-dark .mtk11 { color: #DCDCAA; }\n  .default-dark .mtk8 { color: #CE9178; }\n  .default-dark .mtk15 { color: #C586C0; }\n  .default-dark .mtk10 { color: #4EC9B0; }\n  .default-dark .mtk7 { color: #B5CEA8; }\n  .default-dark .mtk3 { color: #6A9955; }\n  .default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","frontmatter":{"date":"June 21, 2023","title":"(번역) React Query를 사용하여 서버 상태를 관리하는 방법","categories":"react","author":"soobing"},"fields":{"slug":"/react/How-to-manage-server-state-with-React-Query/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://soobing.github.io","comments":{"utterances":{"repo":"soobing/soobing.github.io"}}}}},"pageContext":{"slug":"/javascript/garbage-collection/","nextSlug":"/react/How-to-manage-server-state-with-React-Query/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","2938748437"]}