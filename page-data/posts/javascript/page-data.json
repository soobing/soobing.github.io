{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/javascript",
    "result": {"pageContext":{"currentCategory":"javascript","categories":["All","javascript","react","cs","feature","troubleshooting","browser","infra"],"edges":[{"node":{"id":"f8324742-7b5b-565c-8a3e-467fb9b74538","excerpt":"힙과 스택 메모리의 차이를 살펴보고, 자바스크립트 대표 엔진인 V8의 Resident set 구조와 Minor GC, Major GC 의 동작 알고리즘에 대해서 자세하게 살펴 보도록 하겠습니다. 이 글이 가비지 컬렉터가 어떻게 동작하는지 이해하는데 도움이 되길 바랍니다. V8 메모리 구조 (feat. Resident set) Resident Set은 실행 중인 프로그램의 메모리 관리를 위해 사용되는 용어로, 현재 V8 프로세스가 사용하는 모든 메모리를 나타냅니다. 이것은 JavaScript 코드, 객체, 함수, 변수 등을 저장하는 데 필요한 모든 메모리를 포함합니다. Resident Set은 다음과 같이 여러 세그먼트로 구성됩니다. \n출처: memory management in V8 stack vs heap 메모리 공간은 크게 스택 메모리(Stack memory)와 힙 메모리(Heap memory)로 구분되며, 힙 메모리는 다양한 목적으로 서비스하는 여러 공간으로 더 나누어집니다.…","fields":{"slug":"/javascript/garbage-collection/"},"frontmatter":{"categories":"javascript","title":"자바스크립트 가비지 컬렉션 알고리즘","date":"July 14, 2023","draft":false}},"next":{"fields":{"slug":"/react/How-to-manage-server-state-with-React-Query/"}},"previous":null},{"node":{"id":"eaea877f-7490-5d24-8504-b7fb5e80a6cc","excerpt":"ES6에서는 Proxy, Reflect 객체를 통해 메타프로그래밍을 할 수 있습니다. 메타프로그래밍이 무엇인지? 그리고 Proxy와 Reflect에 대해서 알아보도록 하겠습니다. Metaprogramming 메타프로그래밍은 프로그램이 자기 자신을 조작할 수 있는 능력을 말합니다. 이를 통해 프로그램은 동적으로 자기 자신을 변화시키거나, 다른 프로그램을 분석하거나, 새로운 코드를 생성할 수 있습니다. 메타프로그래밍을 통해 코드의 유연성과 재사용성을 높일 수 있으며, 런타임에서 객체의 동작을 수정할 수 있어서 더욱 강력한 코드를 작성할 수 있습니다. 메타프로그래밍에서 가장 중요한 세 가지 개념 Introspection Introspection은 코드가 자기 자신을 검사할 수 있는 능력을 의미합니다. 이를 통해 코드의 내부 구조와 데이터를 검사하거나, 코드의 실행 시점에서 객체의 메소드나 프로퍼티에 접근할 수 있습니다. 자바스크립트에서는 ES6부터 Reflect 객체를 제공하여 Intr…","fields":{"slug":"/javascript/metaprogramming/"},"frontmatter":{"categories":"javascript","title":"Proxy, Reflect와 메타프로그래밍","date":"May 07, 2023","draft":false}},"next":{"fields":{"slug":"/javascript/deep-copying-objects-with-the-structuredclone-api/"}},"previous":{"fields":{"slug":"/cs/6-caching-strategies/"}}},{"node":{"id":"7005dd6c-6771-5e1c-bdef-ca1048b02a0a","excerpt":"원문: https://blog.openreplay.com/deep-copying-objects-with-the-structuredclone-api/ Deep Copying Objects with the StructuredClone API 개요: 자바스크립트에서 객체를 복사하는 것은 간단하지 않으며, 이는 잘 알려진 문제입니다. 그러나 이 글에서는 해결책을 제공합니다. StructuredClone API를 사용하면 모든 객체를 간단하고 빠르게 복사할 수 있습니다. 자바스크립트에서 객체가 변수에 저장될 때, 해당 변수는 객체의 참조값을 갖습니다. 이는 변수 자체에 객체를 저장하는 것이 아니라, 객체의 메모리 위치를 나타내는 식별자를 저장한다는 것을 의미합니다. 객체의 복사는 원시 타입과는 다른 방식으로 동작합니다. 얕은 복사(Shallow Copy) vs. 깊은 복사(Deep Copy) 자바스크립트에서 값은 두 가지 방법으로 복사할 수 있습니다. 얕은 복사와 깊은 복사입니다. 얕은 복…","fields":{"slug":"/javascript/deep-copying-objects-with-the-structuredclone-api/"},"frontmatter":{"categories":"javascript","title":"(번역) StructuredClone API를 사용하여 객체를 깊은 복사하는 법","date":"May 07, 2023","draft":false}},"next":{"fields":{"slug":"/feature/input-date/"}},"previous":{"fields":{"slug":"/javascript/metaprogramming/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}